---
title: "Intermediate data check"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, error=TRUE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(knitr)
library(kableExtra)
library(rlang)
library(scales)
```

<br> 

```{r , echo = FALSE, message = FALSE}

## read files

## read files
# harmonized and converted data file
detailed <- read_rds("./detailed_data/03_intermediate/all_tables_converted.rds")

# list of columns
sheets_columns <- read_delim("./detailed_data/01_input/02_lists_and_concordance_tables/sheets_columns.csv", delim = ";")


# sheets
sheet_min <- detailed$minerals_ores_conce
sheet_com <- detailed$commodities

```

<br> 

```{r setup, include=FALSE, error=TRUE}
## Add duplicates for "Ore processed" from "Ore mined" and vice versa
  ## These duplicates are only for checking and do not represent the actual duplicates introduced later after aggregation (the main reason being that without prior aggregation the duplicates would create false values, especially due to different sub-sites, different mining types, and different ores)

ore_mined <- sheet_min %>%
  filter(type_mineral == "Ore mined") %>%
  distinct(mine_fac, year)

ore_proc <- sheet_min %>%
  filter(type_mineral == "Ore processed") %>%
  distinct(mine_fac, year)

# mines with reported ore mined for a year, but no ore processed for that year
mine_list <- setdiff(ore_mined, ore_proc)

sheet_min <- sheet_min %>% 
  union(
    mine_list %>%
      left_join(sheet_min %>% filter(type_mineral == "Ore mined")) %>%
      mutate(type_mineral = "Ore processed")
    )

# mines with reported ore processed, but no ore mined for that year
mine_list <- setdiff(ore_proc, ore_mined)

sheet_min <- sheet_min %>% 
  union(
    mine_list %>%
      left_join(sheet_min %>% filter(type_mineral == "Ore processed")) %>%
      mutate(type_mineral = "Ore mined")
  )

```

<br> 

```{r setup, include=FALSE, error=TRUE}
## Add duplicates for "Clean coal" from "Coal mined" and vice versa
  ## These duplicates are only for checking and do not represent the actual duplicates introduced later after aggregation (the main reason being that without prior aggregation the duplicates would create false values, especially due to different sub-sites, different mining types, and different ores)

ore_mined <- sheet_min %>%
  filter(type_mineral == "Coal mined") %>%
  distinct(mine_fac, year)

ore_proc <- sheet_min %>%
  filter(type_mineral == "Clean coal") %>%
  distinct(mine_fac, year)

# mines with reported coal mined for a year, but no Clean coal for that year
mine_list <- setdiff(ore_mined, ore_proc)

sheet_min <- sheet_min %>% 
  union(
    mine_list %>%
      left_join(sheet_min %>% filter(type_mineral == "Coal mined")) %>%
      mutate(type_mineral = "Clean coal")
  )

# mines with reported Clean coal, but no coal mined for that year
mine_list <- setdiff(ore_proc, ore_mined)

sheet_min <- sheet_min %>% 
  union(
    mine_list %>%
      left_join(sheet_min %>% filter(type_mineral == "Clean coal")) %>%
      mutate(type_mineral = "Coal mined")
  )

```

<br> 

#### Mines which are in both tables, but are not joined

```{r setup, include=FALSE, error=TRUE}
## check which rows from sheet_min would not be included in join of sheet_com, because variables don't fit

# list of same mines in both sheets
inter_mine <- intersect(sheet_min["mine_fac"], sheet_com["mine_fac"]) %>% distinct(mine_fac)


# join sheet_com with sheet_min by six variables
  # and only for those type_mineral which are to be joined
combined <- sheet_com %>%
  left_join(.,
            sheet_min %>%
              filter(type_mineral %in% c("Ore processed", "Concentrate")) %>%
              select(mine_fac, sub_site, min_ore_con, type_mining, year, mine_processing),
            by = c("mine_fac", "sub_site", "min_ore_con", "type_mining", "year", "mine_processing"),
            suffix = c(".com", ".min")
            ) %>%
  distinct(mine_fac)


# mines which are in both tables, but are not joined
non_fit <- combined %>%
  filter(!mine_fac %in% inter_mine$mine_fac)


# table for Rmd output
DT::datatable(not_fit)  



# exclude those from sheet_min (just for the check) which are not Oxide ores and at the same time have also a concentrate production reported (e.g. sulphide ore resulting in concentrate), because then content is likely provided for concentrate already


```

<br> 

#### Check for same mine having entries by more than one company in a year (sheet_min)
```{r setup, include=FALSE, error=TRUE}

a <- sheet_min %>%
  distinct(mine_fac, year, source_id)

a <- a %>%
  group_by(mine_fac, year) %>%
  summarise(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

# table for Rmd output
DT::datatable(a)  

```

<br> 

#### Check for same mine having entries by more than one company in a year (sheet_com)
```{r setup, include=FALSE, error=TRUE}

a <- sheet_com %>%
  distinct(mine_fac, year, source_id)

a <- a %>%
  group_by(mine_fac, year) %>%
  summarise(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

# table for Rmd output
DT::datatable(a)  

```

<br> 

```{r setup, include=FALSE, error=TRUE}

### check values per mine/material for one year vs next to check for potential typos, i.e. outliers in time series



# indiv_mat <- sheet_min
# 
# sheet_min %>%
#   distinct(mine_fac, sub_site, min_ore_con, type_mining, year, mine_processing)
# 
# 
# 
# 
# 
# for (i in 1:2) {
# 
#   indiv_mat[,i] %>%
#     left_join(sheet_min)
#
# 
#   for (j in 1:2) {
# 
# 
#   }
# 
# }


# table for Rmd output
#DT::datatable()  

```

<br> 

```{r}

### check for double counting between ores and concentrates

# a <- sheet_com %>%
#   group_by(mine_fac, sub_site, commodity, type_mining, year, mine_processing) %>%
#   summarise(n = n()) %>%
#   ungroup() %>%
#   filter(n > 1) %>%
#   left_join(sheet_com)



```

<br> 

```{r}



```

<br> 

```{r}

```

